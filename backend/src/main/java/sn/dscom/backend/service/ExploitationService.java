package sn.dscom.backend.service;

import com.google.common.base.Strings;
import io.vavr.control.Try;
import lombok.Builder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.http.HttpStatus;
import org.springframework.transaction.annotation.Transactional;
import sn.dscom.backend.common.constants.Enum.ErreurEnum;
import sn.dscom.backend.common.dto.AutocompleteRecherche;
import sn.dscom.backend.common.dto.ChargementDTO;
import sn.dscom.backend.common.dto.CritereRecherche;
import sn.dscom.backend.common.dto.ExploitationDTO;
import sn.dscom.backend.common.exception.CommonMetierException;
import sn.dscom.backend.common.util.pojo.Transformer;
import sn.dscom.backend.database.entite.CategorieEntity;
import sn.dscom.backend.database.entite.ExploitationEntity;
import sn.dscom.backend.database.entite.SiteEntity;
import sn.dscom.backend.database.repository.ExploitationRepository;
import sn.dscom.backend.service.converter.ExploitationConverter;
import sn.dscom.backend.service.interfaces.IExploitationService;
import sn.dscom.backend.service.util.CategorieSpecifications;
import sn.dscom.backend.service.util.ExploitationSpecifications;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * @apiNote implémentation des operations sur les sites d'exploitation
 * @version 1
 */
@Transactional
public class ExploitationService implements IExploitationService {

    /** Logger Factory */
    private static final Logger logger = LoggerFactory.getLogger(ExploitationService.class);

    /**
     * exploitation Repository
     */
    private final ExploitationRepository exploitationRepository;

    /**
     * explitation Converteur
     */
    private final Transformer<ExploitationDTO, ExploitationEntity> explitationConverteur = new ExploitationConverter();

    /**
     * ExploitationService
     * @param exploitationRepository exploitationRepository
     */
    @Builder
    public ExploitationService(ExploitationRepository exploitationRepository) {
        this.exploitationRepository = exploitationRepository;
    }

    /**
     * Permet de modifier ou de creer un site Exploitation
     *
     * @param exploitationDTO le site à enregistrer ou à modifier
     * @return le site enregistrer
     */
    @Override
    public Optional<ExploitationDTO> enregistrerSiteExploitation(ExploitationDTO exploitationDTO) {

        ExploitationService.logger.info(String.format("Enregistrer Site Exploitation: %s", exploitationDTO));
        // Vérifiacation
        ExploitationEntity exploitationEntity = this.exploitationRepository.isSiteExploitationExist(exploitationDTO.getNom().trim().toUpperCase(), exploitationDTO.getRegion().trim().toUpperCase());

        // s'il existe on renvoit le site existant
        if(exploitationEntity != null && exploitationDTO.getId() == null ){
            return Optional.of(Try.of(() ->exploitationEntity)
                                    .mapTry(this.explitationConverteur::reverse)
                                    .onFailure(e -> ExploitationService.logger.error(String.format("Erreur lors du reverse: %s", e.getMessage())))
                                    .get()
            );
        }
        //C'est la séquence qui génère l'id en cas de création
        return Optional.of(Try.of(() -> this.explitationConverteur.transform(exploitationDTO))
                .mapTry(this.exploitationRepository::save)
                .onFailure(e -> ExploitationService.logger.error(String.format("Erreur lors du save: %s", e.getMessage())))
                .mapTry(this.explitationConverteur::reverse)
                .onFailure(e -> ExploitationService.logger.error(String.format("Erreur lors du reverse: %s", e.getMessage())))
                .get());
    }

    /**
     * Retourne l'ensemble des sites d'Exploitation
     *
     * @return la liste des sites
     */
    @Override
    public Optional<List<ExploitationDTO>> rechercherSitesExploitation() {

        ExploitationService.logger.info(String.format("Rechercher Sites Exploitation"));
        // On charge l'ensemble des site
        List<ExploitationEntity> listSitesFind = this.exploitationRepository.findAll();

        //retourne la liste
        return Optional.of(listSitesFind.stream()
                .map(this.explitationConverteur::reverse)
                .filter(Objects::nonNull)
                .collect(Collectors.toList()));
    }

    /**
     * Permet de faire une recherche spécifique: exemple id
     *
     * @param exploitationDTO exploitationDTO
     * @return la liste trouvée
     */
    @Override
    public Optional<List<ExploitationDTO>> rechercherSiteExploitation(ExploitationDTO exploitationDTO) {
        ExploitationService.logger.info(String.format("Rechercher Site Exploitation: %s", exploitationDTO));
        //recherche par id
        if (exploitationDTO.getId() != null) {

            ExploitationService.logger.info(String.format("Rechercher Site Exploitation par : %s", exploitationDTO.getId()));
            return Optional.of(Collections.singletonList(Try.of(exploitationDTO::getId)
                                                        .mapTry(this.exploitationRepository::findById)
                                                        .onFailure(e -> ExploitationService.logger.error(String.format("Erreur lors du findById: %s", e.getMessage())))
                                                        .get()
                                                        .map(this.explitationConverteur::reverse).get())
            );

        } else if (!Strings.isNullOrEmpty(exploitationDTO.getNom())) {

            ExploitationService.logger.info(String.format("Rechercher Site Exploitation par : %s", exploitationDTO.getNom()));
            return Optional.of(Collections.singletonList(Try.of(() -> this.exploitationRepository.isSiteExploitationExistByNam(exploitationDTO.getNom().trim().toUpperCase()))
                                                            .mapTry(this.explitationConverteur::reverse)
                                                            .onFailure(e -> ExploitationService.logger.error(String.format("Erreur lors de la rechercher Site Exploitation: %s", e.getMessage())))
                                                            .get())
            );
        }
        //TODO: a implementer pour d'autre recherche
        return Optional.empty();
    }

    /**
     * Permet de supprimer un site
     *
     * @param exploitationDTO exploitationDTO
     * @return true si supprimé
     */
    @Override
    public Boolean supprimerSiteExploitation(ExploitationDTO exploitationDTO) {
        try {
            // on supprime par id
            this.exploitationRepository.deleteById(exploitationDTO.getId());
            return true;
        }catch (Exception e){
            throw new CommonMetierException(HttpStatus.NON_AUTHORITATIVE_INFORMATION.value(), ErreurEnum.ERR_INATTENDUE);

        }
    }

    /**
     * Permet de comter le nombre de site en base
     *
     * @param dateMiseEnService dateMiseEnService
     * @return le nombre de site d'Exploitation
     */
    @Override
    public Integer compterSiteExploitation(LocalDateTime dateMiseEnService) {
        return exploitationRepository.compterSitePardate(dateMiseEnService);
    }

    /**
     * rechercher Site Exploitation by Id
     * @param id à rechercher
     * @return retour le site
     */
    @Override
    public ExploitationDTO rechercherSiteExploitationbyId(long id) {

        try {
            Optional<ExploitationEntity> exploitationEntity = exploitationRepository.findById(id);
            if (exploitationEntity.isPresent()) {
                return this.explitationConverteur.reverse(exploitationEntity.get());
            }
            // retourner un message d'erreur édéquat: ici "le site avec {id} n'existe pas -> 404"
            // ce n'est pas une erreur inattendue: ErreurEnum.ERR_INATTENDUE
            throw new CommonMetierException(HttpStatus.NOT_FOUND.value(), ErreurEnum.ERR_INATTENDUE);
        } catch (CommonMetierException e) {
            //todo
            throw e;

        }
    }

    /**
     * get All Region
     *
     * @return liste
     */
    @Override
    public List<String> getAllRegion() {
        return this.exploitationRepository.findListRegion();
    }

    /**
     * find ExploitationEntities By Region
     *
     * @param region la région
     * @return la liste
     */
    @Override
    public List<ExploitationDTO> findExploitationEntitiesByRegion(String region) {
        Optional<List<ExploitationEntity>> list = this.exploitationRepository.findExploitationEntitiesByRegion(region.trim().toUpperCase());
        ExploitationService.logger.info(String.format("Liste des sites pour la region %s est : %s", region, list.get()));
        return Try.of(list::get)
                .getOrElse(Collections.emptyList())
                .stream()
                .filter(Objects::nonNull)
                .map(this.explitationConverteur::reverse)
                .collect(Collectors.toList());
    }

    /**
     * rechargement Par Critere
     *
     * @param critereRecherche critereRecherche
     * @return liste
     */
    @Override
    public Page<ExploitationDTO> rechargementParCritere(CritereRecherche<?> critereRecherche) {
        PageRequest pageRequest = PageRequest.of(critereRecherche.getPage(), critereRecherche.getSize());
        if (critereRecherche.getAutocompleteRecherches().size() == 0){
            ExploitationService.logger.info(String.format("Rechercher Sites Exploitation"));

            Page<ExploitationEntity> listSitesFind = this.exploitationRepository.findAll(pageRequest);
            // On charge l'ensemble des site
            List<ExploitationDTO>listSites= listSitesFind.getContent().stream()
                    .map(this.explitationConverteur::reverse)
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());

            return new PageImpl<>(listSites, pageRequest, listSitesFind.getTotalElements());
        }

        List<Long> idsSiteExploitation = new ArrayList<>(critereRecherche.getAutocompleteRecherches().stream()
                .filter(item -> item instanceof AutocompleteRecherche)
                .filter(item -> ((AutocompleteRecherche) item).getTypeClass() == ExploitationEntity.class)
                .map(item -> Long.parseLong(((AutocompleteRecherche) item).getId().toString()))
                .toList());



        List<String> valueRegions = new ArrayList<>(critereRecherche.getAutocompleteRecherches().stream()
                .filter(item -> item instanceof AutocompleteRecherche)
                .filter(item -> ((AutocompleteRecherche) item).getTypeClass() == String.class)
                .filter(item -> ((AutocompleteRecherche) item).getOrigine().equals("Region"))
                .map(item ->((AutocompleteRecherche) item).getId())
                .toList());

        Specification<ExploitationEntity> spec = Specification
                .where(ExploitationSpecifications.withExploitation(idsSiteExploitation, valueRegions));

        Page<ExploitationEntity> listExploitationFind= this.exploitationRepository.findAll(spec,pageRequest);
        List<ExploitationDTO>listSites= listExploitationFind.getContent().stream()
                .map(this.explitationConverteur::reverse)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        return new PageImpl<>(listSites, pageRequest, listExploitationFind.getTotalElements());
    }
}